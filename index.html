<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>撲克牌決鬥 - 單人模式</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            touch-action: manipulation;
        }
        .card {
            width: 80px;
            height: 112px;
            border: 1px solid #9ca3af;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
        }
        .card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .card.played {
            transform: scale(1.1);
            border-width: 2px;
            border-color: #2563eb;
        }
        .card-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .card-suit {
            font-size: 1.25rem;
        }
        .card-back {
            background: linear-gradient(135deg, #6b7280 25%, transparent 25%) -40px 0, linear-gradient(225deg, #6b7280 25%, transparent 25%) -40px 0, linear-gradient(315deg, #6b7280 25%, transparent 25%), linear-gradient(45deg, #6b7280 25%, transparent 25%);
            background-size: 80px 80px;
            background-color: #4b5563;
        }
        .heart { color: #ef4444; }
        .diamond { color: #ef4444; }
        .spade { color: #1f2937; }
        .club { color: #1f2937; }
        #game-screen {
            background-image: radial-gradient(circle, #374151, #1f2937);
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <!-- 主容器 -->
    <div id="app-container" class="w-full max-w-md mx-auto">

        <!-- 大廳介面 -->
        <div id="lobby" class="bg-slate-800 p-8 rounded-lg shadow-2xl">
            <h1 class="text-4xl font-bold text-center mb-2">撲克牌決鬥</h1>
            <p class="text-center text-slate-400 mb-8">單人對戰版 (AI 加持)</p>
            <div class="space-y-4">
                <input type="text" id="player-name" placeholder="輸入你的暱稱" class="w-full bg-slate-700 text-white p-3 rounded-md border border-slate-600 focus:outline-none focus:ring-2 focus:ring-blue-500" value="玩家">
                <button id="start-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-md transition duration-200">開始遊戲</button>
            </div>
             <p id="lobby-error" class="text-red-400 text-center mt-4"></p>
        </div>

        <!-- 遊戲介面 -->
        <div id="game-screen" class="hidden h-screen max-h-[800px] w-full max-w-md mx-auto flex flex-col p-4 rounded-lg shadow-2xl relative">
            <!-- 頂部資訊 -->
            <div class="flex justify-between items-center mb-4 text-slate-300">
                <div id="player-name-display-top" class="font-bold">玩家</div>
                <div>第 <span id="round-counter">1</span> 回合</div>
                <div class="text-lg">🏆 <span id="player-wins">0</span> - <span id="computer-wins">0</span></div>
            </div>

            <!-- 電腦區域 -->
            <div id="computer-area" class="flex flex-col items-center justify-center flex-grow">
                <div class="text-center mb-2">
                    <div class="flex items-center justify-center space-x-2">
                        <div id="computer-name" class="text-lg font-bold text-slate-300">電腦</div>
                    </div>
                    <div class="text-2xl font-bold text-red-500">❤️ <span id="computer-hp">25</span></div>
                </div>
                <div class="relative w-40 h-40 flex items-center justify-center">
                    <div id="computer-played-card" class="absolute"></div>
                </div>
                <div id="computer-hand" class="flex justify-center space-x-[-40px] mt-2">
                    <!-- 電腦手牌將會動態生成 -->
                </div>
            </div>

            <!-- 遊戲日誌 -->
            <div id="game-log" class="text-center text-amber-300 h-10 my-2 text-sm flex items-center justify-center"></div>
            <div id="gemini-actions" class="h-10 my-2 flex items-center justify-center space-x-4"></div>

            <!-- 玩家區域 -->
            <div id="player-area" class="flex flex-col items-center justify-center flex-grow">
                <div id="player-hand" class="flex justify-center space-x-[-20px] mb-2">
                    <!-- 玩家手牌將會動態生成 -->
                </div>
                <div class="relative w-40 h-40 flex items-center justify-center">
                    <div id="player-played-card" class="absolute"></div>
                </div>
                <div class="text-center mt-2">
                    <div class="text-2xl font-bold text-green-500">❤️ <span id="player-hp">25</span></div>
                </div>
            </div>
            
             <!-- 遊戲結束彈窗 -->
            <div id="game-over-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-center p-8">
                <h2 id="game-over-message" class="text-5xl font-bold mb-4"></h2>
                <p id="final-score" class="text-2xl text-slate-300 mb-8"></p>
                <button id="back-to-lobby-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-200">返回大廳</button>
            </div>
        </div>

    </div>

    <script type="module">
        // UI 元素
        const lobby = document.getElementById('lobby');
        const gameScreen = document.getElementById('game-screen');
        const startGameBtn = document.getElementById('start-game-btn');
        const playerNameInput = document.getElementById('player-name');
        const lobbyError = document.getElementById('lobby-error');
        
        // 遊戲狀態
        let gameState = {};

        // --- Gemini API ---
        async function generateGeminiMessage(prompt) {
            const apiKey = ""; // API key is handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    temperature: 0.8,
                    maxOutputTokens: 50,
                }
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                     throw new Error(`API call failed with status: ${response.status}`);
                }
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                return text?.trim() || "…";
            } catch (error) {
                console.error("Gemini API call failed:", error);
                return "我無話可說。";
            }
        }

        // --- 卡牌遊戲核心邏輯 ---

        function createDeck() {
            const suits = ['♠️', '♥️', '♦️', '♣️'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];
            for (const suit of suits) {
                for (const value of values) {
                    deck.push({ suit, value });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function getCardValue(card) {
            if (!card || !card.value) return 0;
            const value = card.value;
            if (value === 'A') return 1;
            if (value === 'J') return 1;
            if (value === 'Q') return 2;
            if (value === 'K') return 11;
            return parseInt(value);
        }

        function getCardType(card) {
            if (!card || !card.suit) return 'none';
            if (['♠️', '♣️'].includes(card.suit)) return 'attack';
            if (card.suit === '♦️') return 'counter';
            if (card.suit === '♥️') return 'heal';
        }

        // --- 單人遊戲邏輯 ---

        startGameBtn.onclick = () => {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                lobbyError.textContent = "請先輸入暱稱。";
                return;
            }
            
            lobby.classList.add('hidden');
            gameScreen.classList.remove('hidden');

            initGame(playerName);
        };

        function initGame(playerName) {
            gameState = {
                playerName: playerName,
                playerWins: 0,
                computerWins: 0,
                currentRound: 1,
                isPlayerTurn: true,
                log: ""
            };
            startNewRound();
        }

        function startNewRound() {
            document.getElementById('gemini-actions').innerHTML = '';
            document.getElementById('player-played-card').innerHTML = '';
            document.getElementById('computer-played-card').innerHTML = '';

            const deck = shuffleDeck(createDeck());
            gameState.playerHp = 25;
            gameState.computerHp = 25;
            gameState.playerHand = deck.splice(0, 5);
            gameState.computerHand = deck.splice(0, 5);
            gameState.deck = deck;
            gameState.isPlayerTurn = true;
            gameState.log = `第 ${gameState.currentRound} 回合開始！請出牌。`;
            renderGame();
        }

        function playCard(card, index) {
            if (!gameState.isPlayerTurn) return;
            
            gameState.isPlayerTurn = false; // 鎖定玩家操作
            
            // 玩家出牌
            const playerCard = gameState.playerHand.splice(index, 1)[0];
            
            // 電腦出牌
            const { card: computerCard, index: computerIndex } = computerChooseCard(playerCard);
            gameState.computerHand.splice(computerIndex, 1);

            // 渲染出的牌
            document.getElementById('player-played-card').innerHTML = renderCard(playerCard);
            document.getElementById('computer-played-card').innerHTML = renderCard(computerCard);
            renderGame(); // 更新手牌數量

            // 延遲一下再結算
            setTimeout(() => {
                resolveRound(playerCard, computerCard);
            }, 1000);
        }

        function computerChooseCard(playerCard) {
            const computerHand = gameState.computerHand;
            const playerCardType = getCardType(playerCard);
            let bestCard = null;
            let bestCardIndex = -1;

            // 策略1: 如果玩家攻擊，優先考慮反擊
            if (playerCardType === 'attack') {
                const counters = computerHand.map((c, i) => ({ card: c, index: i }))
                                         .filter(item => getCardType(item.card) === 'counter');
                if (counters.length > 0) {
                    // 選擇最強的反擊牌
                    counters.sort((a, b) => getCardValue(b.card) - getCardValue(a.card));
                    return counters[0];
                }
            }

            // 策略2: 如果血量低於10，優先考慮補血
            if (gameState.computerHp < 10) {
                 const healers = computerHand.map((c, i) => ({ card: c, index: i }))
                                         .filter(item => getCardType(item.card) === 'heal');
                if (healers.length > 0) {
                     healers.sort((a, b) => getCardValue(b.card) - getCardValue(a.card));
                    return healers[0];
                }
            }
            
            // 策略3: 優先出攻擊牌
            const attackers = computerHand.map((c, i) => ({ card: c, index: i }))
                                         .filter(item => getCardType(item.card) === 'attack');
            if (attackers.length > 0) {
                 attackers.sort((a, b) => getCardValue(b.card) - getCardValue(a.card));
                return attackers[0];
            }

            // 策略4: 如果沒有攻擊牌，隨機出
            bestCardIndex = Math.floor(Math.random() * computerHand.length);
            bestCard = computerHand[bestCardIndex];
            return { card: bestCard, index: bestCardIndex };
        }

        async function resolveRound(playerCard, computerCard) {
            const p1Type = getCardType(playerCard);
            const p2Type = getCardType(computerCard);
            const p1Value = getCardValue(playerCard);
            const p2Value = getCardValue(computerCard);

            let logMessages = [`你打出 ${playerCard.value}${playerCard.suit}`, `電腦打出 ${computerCard.value}${computerCard.suit}`];

            // 1. 攻擊階段
            if (p1Type === 'attack' && p2Type !== 'counter') {
                gameState.computerHp -= p1Value;
                logMessages.push(`你造成 ${p1Value} 點傷害。`);
            }
            if (p2Type === 'attack' && p1Type !== 'counter') {
                gameState.playerHp -= p2Value;
                logMessages.push(`電腦造成 ${p2Value} 點傷害。`);
            }

            // 2. 反擊階段
            if (p1Type === 'counter' && p2Type === 'attack') {
                gameState.computerHp -= p1Value;
                logMessages.push(`你反擊了 ${p1Value} 點傷害！`);
            }
            if (p2Type === 'counter' && p1Type === 'attack') {
                gameState.playerHp -= p2Value;
                logMessages.push(`電腦反擊了 ${p2Value} 點傷害！`);
            }

            // 3. 治療階段
            if (p1Type === 'heal') {
                gameState.playerHp = Math.min(25, gameState.playerHp + p1Value);
                logMessages.push(`你恢復了 ${p1Value} 點生命。`);
            }
            if (p2Type === 'heal') {
                gameState.computerHp = Math.min(25, gameState.computerHp + p2Value);
                logMessages.push(`電腦恢復了 ${p2Value} 點生命。`);
            }

            gameState.playerHp = Math.max(0, gameState.playerHp);
            gameState.computerHp = Math.max(0, gameState.computerHp);
            
            // 判斷回合勝負
            let roundWinner = null;
            if (gameState.playerHp <= 0 && gameState.computerHp > 0) {
                roundWinner = 'computer';
                logMessages.push(`電腦贏得此回合！`);
            } else if (gameState.computerHp <= 0 && gameState.playerHp > 0) {
                roundWinner = 'player';
                logMessages.push(`你贏得此回合！`);
            } else if (gameState.playerHp <= 0 && gameState.computerHp <= 0) {
                logMessages.push("此回合平手！");
            } else {
                 logMessages.push("回合結束，雙方都還活著！");
            }

            gameState.log = logMessages.join(' ');
            if (roundWinner === 'player') gameState.playerWins++;
            if (roundWinner === 'computer') gameState.computerWins++;

            renderGame();
            handleGeminiActions(roundWinner);
            
            // 檢查遊戲是否結束 (BO5)
            if (gameState.playerWins >= 3 || gameState.computerWins >= 3) {
                setTimeout(showGameOver, 2000);
            } else {
                 setTimeout(goToNextRound, 4000);
            }
        }
        
        function handleGeminiActions(roundWinner){
            const geminiActions = document.getElementById('gemini-actions');
            geminiActions.innerHTML = '';
             if (roundWinner) {
                let buttonText, prompt;
                if (roundWinner === 'player') {
                    buttonText = '發表勝利感言 🎤';
                    prompt = `你是一位撲克牌高手，剛在「撲克牌決鬥」遊戲中贏了一個回合。請用繁體中文生成一句簡短 (15字以內)、有趣且帶點嗆聲意味的勝利感言。`;
                } else {
                    buttonText = '稱讚對手 👍';
                    prompt = `你是一位有風度的撲克牌玩家，剛在「撲克牌決鬥」遊戲中輸了一個回合。請用繁體中文生成一句簡短 (15字以內)、誠懇地稱讚對手的話。`;
                }

                const geminiBtn = document.createElement('button');
                geminiBtn.textContent = buttonText;
                geminiBtn.className = 'bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md transition';
                geminiBtn.onclick = async () => {
                    geminiBtn.disabled = true;
                    geminiBtn.textContent = '生成中...';
                    const message = await generateGeminiMessage(prompt);
                    document.getElementById('game-log').innerHTML += `<br/><span class='text-purple-300'>${gameState.playerName}: "${message}"</span>`;
                    geminiActions.innerHTML = '';
                };
                geminiActions.appendChild(geminiBtn);
            }
        }

        function goToNextRound() {
            gameState.currentRound++;
            startNewRound();
        }
        
        function showGameOver(){
            const modal = document.getElementById('game-over-modal');
            const message = document.getElementById('game-over-message');
            const score = document.getElementById('final-score');
            
            if(gameState.playerWins >= 3){
                message.textContent = "恭喜你獲勝！";
            } else {
                message.textContent = "可惜，電腦獲勝了！";
            }
            score.textContent = `最終比分 ${gameState.playerWins} - ${gameState.computerWins}`;
            modal.classList.remove('hidden');
        }


        // --- 畫面渲染 ---
        
        function renderCard(card, isFaceDown = false) {
            if (isFaceDown) {
                return `<div class="card card-back"></div>`;
            }
            
            const suitClass = { '♠️': 'spade', '♣️': 'club', '♥️': 'heart', '♦️': 'diamond' }[card.suit];
            return `
                <div class="card ${suitClass}">
                    <div class="text-left">
                        <span class="card-value">${card.value}</span>
                        <span class="card-suit">${card.suit}</span>
                    </div>
                    <div class="text-right self-end rotate-180">
                        <span class="card-value">${card.value}</span>
                        <span class="card-suit">${card.suit}</span>
                    </div>
                </div>
            `;
        }
        
        function renderGame() {
            if (!gameState || !gameState.playerName) return;

            // 更新頂部資訊
            document.getElementById('player-name-display-top').textContent = gameState.playerName;
            document.getElementById('round-counter').textContent = gameState.currentRound;
            document.getElementById('player-wins').textContent = gameState.playerWins;
            document.getElementById('computer-wins').textContent = gameState.computerWins;

            // 更新HP
            document.getElementById('player-hp').textContent = gameState.playerHp;
            document.getElementById('computer-hp').textContent = gameState.computerHp;
            
            // 渲染手牌
            const playerHandDiv = document.getElementById('player-hand');
            playerHandDiv.innerHTML = '';
            gameState.playerHand.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.innerHTML = renderCard(card);
                if (gameState.isPlayerTurn) {
                     cardEl.onclick = () => playCard(card, index);
                }
                playerHandDiv.appendChild(cardEl.firstChild);
            });
            
            const computerHandDiv = document.getElementById('computer-hand');
            computerHandDiv.innerHTML = Array(gameState.computerHand.length).fill(renderCard(null, true)).join('');
            
            // 更新日誌
            document.getElementById('game-log').innerHTML = gameState.log;
        }
        
        document.getElementById('back-to-lobby-btn').onclick = () => {
             window.location.reload();
        };

    </script>
</body>
</html>

